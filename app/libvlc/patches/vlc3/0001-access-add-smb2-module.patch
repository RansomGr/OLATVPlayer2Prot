From 9f981e2650b2a6707d707a974ce63d570bb87e3c Mon Sep 17 00:00:00 2001
Message-Id: <9f981e2650b2a6707d707a974ce63d570bb87e3c.1568976855.git.thomas@gllm.fr>
From: Thomas Guillem <thomas@gllm.fr>
Date: Fri, 13 Apr 2018 16:15:16 +0200
Subject: [PATCH 1/7] access: add smb2 module

Using libsmb2 from Ronnie Sahlberg https://github.com/sahlberg/libsmb2
This is LGPL 2.1 fully async lib for accessing SMB2 and SMB3 shares.

This module use the async feature of the libsmb2 lib with the vlc interrupt
mechanism, therefore every network requests are cancellable almost immediately.

The 2.0.0 version is required since this version drop OpenSSL dependency and
allow to use Builtin NTLMSSP authentication instead of libkrb5.
---
 configure.ac                                  |  14 +-
 ...ssp-add-support-for-Anonymous-logins.patch | 219 ++++++
 .../0002-Fix-indent-and-white-spaces.patch    |  97 +++
 .../src/smb2/0003-Fix-getlogin-usage.patch    |  70 ++
 ...troy_context-fix-possible-null-deref.patch |  48 ++
 contrib/src/smb2/SHA512SUMS                   |   1 +
 contrib/src/smb2/rules.mak                    |  31 +
 modules/MODULES_LIST                          |   1 +
 modules/access/Makefile.am                    |  11 +
 modules/access/smb2.c                         | 734 ++++++++++++++++++
 po/POTFILES.in                                |   1 +
 11 files changed, 1226 insertions(+), 1 deletion(-)
 create mode 100644 contrib/src/smb2/0001-ntlmssp-add-support-for-Anonymous-logins.patch
 create mode 100644 contrib/src/smb2/0002-Fix-indent-and-white-spaces.patch
 create mode 100644 contrib/src/smb2/0003-Fix-getlogin-usage.patch
 create mode 100644 contrib/src/smb2/0004-smb2_destroy_context-fix-possible-null-deref.patch
 create mode 100644 contrib/src/smb2/SHA512SUMS
 create mode 100644 contrib/src/smb2/rules.mak
 create mode 100644 modules/access/smb2.c

diff --git a/configure.ac b/configure.ac
index 304db5fabf..41aa6917ea 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1854,7 +1854,14 @@ AS_IF([test "${SYS}" = "mingw32" -a "${enable_winstore_app}" != "yes"], [ VLC_AD
 dnl
 dnl  liBDSM access module
 dnl
-PKG_ENABLE_MODULES_VLC([DSM], [dsm], [libdsm >= 0.2.0], [libdsm SMB/CIFS access/sd module], [auto])
+AM_CONDITIONAL(HAVE_DSM, [test "$AS_TR_SH(with_dsm)" = "yes"])
+PKG_WITH_MODULES([DSM], [libdsm >= 0.2.0], [
+       VLC_ADD_PLUGIN([dsm])
+       VLC_ADD_CFLAGS([dsm], [$DSM_CFLAGS])
+       VLC_ADD_LIBS([dsm], [$DSM_LIBS])
+       have_dsm="yes"
+   ],,[libdsm SMB/CIFS access/sd module], [auto])
+AM_CONDITIONAL([HAVE_DSM], [test "${have_dsm}" = "yes"])
 
 dnl
 dnl sftp access support
@@ -1866,6 +1873,11 @@ dnl nfs access support
 dnl
 PKG_ENABLE_MODULES_VLC([NFS], [nfs], [libnfs >= 1.10.0], (support nfs protocol via libnfs), [auto])
 
+dnl
+dnl smb2 access support
+dnl
+PKG_ENABLE_MODULES_VLC([SMB2], [smb2], [libsmb2 >= 3.0.0], (support smb2 protocol via libsmb2), [auto])
+
 dnl
 dnl  Video4Linux 2
 dnl
diff --git a/contrib/src/smb2/0001-ntlmssp-add-support-for-Anonymous-logins.patch b/contrib/src/smb2/0001-ntlmssp-add-support-for-Anonymous-logins.patch
new file mode 100644
index 0000000000..3be16c99ff
--- /dev/null
+++ b/contrib/src/smb2/0001-ntlmssp-add-support-for-Anonymous-logins.patch
@@ -0,0 +1,219 @@
+From 1bf49f51d27e87230d826b6f482db312c693586f Mon Sep 17 00:00:00 2001
+From: Ronnie Sahlberg <ronniesahlberg@gmail.com>
+Date: Tue, 6 Aug 2019 13:30:51 +1000
+Subject: [PATCH 1/4] ntlmssp: add support for Anonymous logins
+
+Signed-off-by: Ronnie Sahlberg <ronniesahlberg@gmail.com>
+---
+ lib/ntlmssp.c | 131 +++++++++++++++++++++++++++++---------------------
+ 1 file changed, 77 insertions(+), 54 deletions(-)
+
+diff --git a/lib/ntlmssp.c b/lib/ntlmssp.c
+index 646a511..a34d119 100644
+--- a/lib/ntlmssp.c
++++ b/lib/ntlmssp.c
+@@ -96,6 +96,7 @@ struct auth_data {
+ #define NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY         0x00080000
+ #define NTLMSSP_TARGET_TYPE_SERVER                         0x00020000
+ #define NTLMSSP_NEGOTIATE_ALWAYS_SIGN                      0x00008000
++#define NTLMSSP_NEGOTIATE_ANONYMOUS                        0x00000800
+ #define NTLMSSP_NEGOTIATE_NTLM                             0x00000200
+ #define NTLMSSP_NEGOTIATE_SIGN                             0x00000010
+ #define NTLMSSP_REQUEST_TARGET                             0x00000004
+@@ -320,7 +321,7 @@ encode_ntlm_auth(struct smb2_context *smb2, time_t ti,
+         struct ucs2 *ucs2_domain = NULL;
+         struct ucs2 *ucs2_user = NULL;
+         struct ucs2 *ucs2_workstation = NULL;
+-        int NTChallengeResponse_len;
++        int NTChallengeResponse_len = 0;
+         unsigned char NTProofStr[16];
+         unsigned char LMStr[16];
+         uint64_t t;
+@@ -330,14 +331,15 @@ encode_ntlm_auth(struct smb2_context *smb2, time_t ti,
+         uint32_t u32;
+         uint32_t server_neg_flags;
+         unsigned char key_exch[SMB2_KEY_SIZE];
++        uint8_t anonymous = 0;
+ 
+         tv.tv_sec = ti;
+         tv.tv_usec = 0;
+         t = timeval_to_win(&tv);
+ 
+         if (auth_data->password == NULL) {
+-                smb2_set_error(smb2, "No password set, can not use NTLM\n");
+-                goto finished;
++                anonymous = 1;
++                goto encode;
+         }
+ 
+         /*
+@@ -383,6 +385,7 @@ encode_ntlm_auth(struct smb2_context *smb2, time_t ti,
+         smb2_hmac_md5(NTProofStr, 16, ResponseKeyNT, 16, key_exch);
+         memcpy(auth_data->exported_session_key, key_exch, 16);
+ 
++ encode:
+         /*
+          * Generate AUTHENTICATE_MESSAGE
+          */
+@@ -393,14 +396,20 @@ encode_ntlm_auth(struct smb2_context *smb2, time_t ti,
+         encoder(&u32, 4, auth_data);
+ 
+         /* lm challenge response fields */
+-        memcpy(&lm_buf[0], server_challenge, 8);
+-        memcpy(&lm_buf[8], auth_data->client_challenge, 8);
+-        smb2_hmac_md5(&lm_buf[0], 16,
+-                 ResponseKeyNT, 16, LMStr);
+-        u32 = htole32(0x00180018);
+-        encoder(&u32, 4, auth_data);
+-        u32 = 0;
+-        encoder(&u32, 4, auth_data);
++        if (!anonymous) {
++                memcpy(&lm_buf[0], server_challenge, 8);
++                memcpy(&lm_buf[8], auth_data->client_challenge, 8);
++                smb2_hmac_md5(&lm_buf[0], 16,
++                              ResponseKeyNT, 16, LMStr);
++                u32 = htole32(0x00180018);
++                encoder(&u32, 4, auth_data);
++                u32 = 0;
++                encoder(&u32, 4, auth_data);
++        } else {
++                u32 = 0;
++                encoder(&u32, 4, auth_data);
++                encoder(&u32, 4, auth_data);
++        }
+ 
+         /* nt challenge response fields */
+         u32 = htole32((NTChallengeResponse_len<<16)|
+@@ -410,7 +419,7 @@ encode_ntlm_auth(struct smb2_context *smb2, time_t ti,
+         encoder(&u32, 4, auth_data);
+ 
+         /* domain name fields */
+-        if (auth_data->domain) {
++        if (!anonymous && auth_data->domain) {
+                 ucs2_domain = utf8_to_ucs2(auth_data->domain);
+                 if (ucs2_domain == NULL) {
+                         goto finished;
+@@ -427,18 +436,24 @@ encode_ntlm_auth(struct smb2_context *smb2, time_t ti,
+         }
+ 
+         /* user name fields */
+-        ucs2_user = utf8_to_ucs2(auth_data->user);
+-        if (ucs2_user == NULL) {
+-                goto finished;
++        if (!anonymous) {
++                ucs2_user = utf8_to_ucs2(auth_data->user);
++                if (ucs2_user == NULL) {
++                        goto finished;
++                }
++                u32 = ucs2_user->len * 2;
++                u32 = htole32((u32 << 16) | u32);
++                encoder(&u32, 4, auth_data);
++                u32 = 0;
++                encoder(&u32, 4, auth_data);
++        } else {
++                u32 = 0;
++                encoder(&u32, 4, auth_data);
++                encoder(&u32, 4, auth_data);
+         }
+-        u32 = ucs2_user->len * 2;
+-        u32 = htole32((u32 << 16) | u32);
+-        encoder(&u32, 4, auth_data);
+-        u32 = 0;
+-        encoder(&u32, 4, auth_data);
+ 
+         /* workstation name fields */
+-        if (auth_data->workstation) {
++        if (!anonymous && auth_data->workstation) {
+                 ucs2_workstation = utf8_to_ucs2(auth_data->workstation);
+                 if (ucs2_workstation == NULL) {
+                         goto finished;
+@@ -460,45 +475,53 @@ encode_ntlm_auth(struct smb2_context *smb2, time_t ti,
+         encoder(&u32, 4, auth_data);
+ 
+         /* negotiate flags */
+-        u32 = htole32(NTLMSSP_NEGOTIATE_56|NTLMSSP_NEGOTIATE_128|
+-                      NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY|
+-                      //NTLMSSP_NEGOTIATE_ALWAYS_SIGN|
+-                      NTLMSSP_NEGOTIATE_NTLM|
+-                      //NTLMSSP_NEGOTIATE_SIGN|
+-                      NTLMSSP_REQUEST_TARGET|NTLMSSP_NEGOTIATE_OEM|
+-                      NTLMSSP_NEGOTIATE_UNICODE);
++        u32 = NTLMSSP_NEGOTIATE_56|NTLMSSP_NEGOTIATE_128|
++                NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY|
++                //NTLMSSP_NEGOTIATE_ALWAYS_SIGN|
++                NTLMSSP_NEGOTIATE_NTLM|
++                //NTLMSSP_NEGOTIATE_SIGN|
++                NTLMSSP_REQUEST_TARGET|NTLMSSP_NEGOTIATE_OEM|
++                NTLMSSP_NEGOTIATE_UNICODE;
++        if (anonymous)
++                u32 |= NTLMSSP_NEGOTIATE_ANONYMOUS;
++        u32 = htole32(u32);
+         encoder(&u32, 4, auth_data);
+ 
+-        /* append domain */
+-        u32 = htole32(auth_data->len);
+-        memcpy(&auth_data->buf[32], &u32, 4);
+-        if (ucs2_domain) {
+-                encoder(ucs2_domain->val, ucs2_domain->len * 2, auth_data);
+-        }
++        if (!anonymous) {
++                /* append domain */
++                u32 = htole32(auth_data->len);
++                memcpy(&auth_data->buf[32], &u32, 4);
++                if (ucs2_domain) {
++                        encoder(ucs2_domain->val, ucs2_domain->len * 2,
++                                auth_data);
++                }
+ 
+-        /* append user */
+-        u32 = htole32(auth_data->len);
+-        memcpy(&auth_data->buf[40], &u32, 4);
+-        encoder(ucs2_user->val, ucs2_user->len * 2, auth_data);
++                /* append user */
++                u32 = htole32(auth_data->len);
++                memcpy(&auth_data->buf[40], &u32, 4);
++                encoder(ucs2_user->val, ucs2_user->len * 2, auth_data);
++
++                /* append workstation */
++                u32 = htole32(auth_data->len);
++                memcpy(&auth_data->buf[48], &u32, 4);
++                if (ucs2_workstation) {
++                        encoder(ucs2_workstation->val,
++                                ucs2_workstation->len * 2, auth_data);
++                }
+ 
+-        /* append workstation */
+-        u32 = htole32(auth_data->len);
+-        memcpy(&auth_data->buf[48], &u32, 4);
+-        if (ucs2_workstation) {
+-                encoder(ucs2_workstation->val, ucs2_workstation->len * 2, auth_data);
++                /* append LMChallengeResponse */
++                u32 = htole32(auth_data->len);
++                memcpy(&auth_data->buf[16], &u32, 4);
++                encoder(LMStr, 16, auth_data);
++                encoder(auth_data->client_challenge, 8, auth_data);
++
++                /* append NTChallengeResponse */
++                u32 = htole32(auth_data->len);
++                memcpy(&auth_data->buf[24], &u32, 4);
++                encoder(NTChallengeResponse_buf, NTChallengeResponse_len,
++                        auth_data);
+         }
+ 
+-        /* append LMChallengeResponse */
+-        u32 = htole32(auth_data->len);
+-        memcpy(&auth_data->buf[16], &u32, 4);
+-        encoder(LMStr, 16, auth_data);
+-        encoder(auth_data->client_challenge, 8, auth_data);
+-
+-        /* append NTChallengeResponse */
+-        u32 = htole32(auth_data->len);
+-        memcpy(&auth_data->buf[24], &u32, 4);
+-        encoder(NTChallengeResponse_buf, NTChallengeResponse_len, auth_data);
+-
+         ret = 0;
+ finished:
+         free(ucs2_domain);
+-- 
+2.20.1
+
diff --git a/contrib/src/smb2/0002-Fix-indent-and-white-spaces.patch b/contrib/src/smb2/0002-Fix-indent-and-white-spaces.patch
new file mode 100644
index 0000000000..66a97508c7
--- /dev/null
+++ b/contrib/src/smb2/0002-Fix-indent-and-white-spaces.patch
@@ -0,0 +1,97 @@
+From 13800418c0c2a8c1b26bf1acb0810004fb874213 Mon Sep 17 00:00:00 2001
+From: Thomas Guillem <thomas@gllm.fr>
+Date: Tue, 30 Jul 2019 17:46:49 +0200
+Subject: [PATCH 2/4] Fix indent and white spaces
+
+No functional changes.
+---
+ lib/init.c | 34 +++++++++++++++++-----------------
+ 1 file changed, 17 insertions(+), 17 deletions(-)
+
+diff --git a/lib/init.c b/lib/init.c
+index e6cf1e5..eab69a5 100644
+--- a/lib/init.c
++++ b/lib/init.c
+@@ -69,12 +69,12 @@ smb2_parse_args(struct smb2_context *smb2, const char *args)
+         while (args && *args != 0) {
+                 char *next, *value;
+ 
+-		next = strchr(args, '&');
++                next = strchr(args, '&');
+                 if (next) {
+                         *(next++) = '\0';
+                 }
+ 
+-		value = strchr(args, '=');
++                value = strchr(args, '=');
+                 if (value) {
+                         *(value++) = '\0';
+                 }
+@@ -135,7 +135,7 @@ struct smb2_url *smb2_parse_url(struct smb2_context *smb2, const char *url)
+                 smb2_set_error(smb2, "URL is too long");
+                 return NULL;
+         }
+-	strncpy(str, url + 6, MAX_URL_SIZE);
++        strncpy(str, url + 6, MAX_URL_SIZE);
+ 
+         args = strchr(str, '?');
+         if (args) {
+@@ -165,7 +165,7 @@ struct smb2_url *smb2_parse_url(struct smb2_context *smb2, const char *url)
+                 *(tmp++) = '\0';
+                 u->user = strdup(ptr);
+                 ptr = tmp;
+-	}
++        }
+         /* server */
+         if ((tmp = strchr(ptr, '/')) != NULL) {
+                 *(tmp++) = '\0';
+@@ -287,7 +287,7 @@ void smb2_destroy_context(struct smb2_context *smb2)
+ void smb2_free_iovector(struct smb2_context *smb2, struct smb2_io_vectors *v)
+ {
+         int i;
+-        
++
+         for (i = 0; i < v->niov; i++) {
+                 if (v->iov[i].free) {
+                         v->iov[i].free(v->iov[i].buf);
+@@ -316,25 +316,25 @@ struct smb2_iovec *smb2_add_iovector(struct smb2_context *smb2,
+ 
+ void smb2_set_error(struct smb2_context *smb2, const char *error_string, ...)
+ {
+-	va_list ap;
+-	char errstr[MAX_ERROR_SIZE] = {0};
++        va_list ap;
++        char errstr[MAX_ERROR_SIZE] = {0};
+ 
+-	va_start(ap, error_string);
+-	if (vsnprintf(errstr, MAX_ERROR_SIZE, error_string, ap) < 0) {
+-		strncpy(errstr, "could not format error string!",
++        va_start(ap, error_string);
++        if (vsnprintf(errstr, MAX_ERROR_SIZE, error_string, ap) < 0) {
++                strncpy(errstr, "could not format error string!",
+                         MAX_ERROR_SIZE);
+-	}
+-	va_end(ap);
+-	if (smb2 != NULL) {
+-		strncpy(smb2->error_string, errstr, MAX_ERROR_SIZE);
+-	}
++        }
++        va_end(ap);
++        if (smb2 != NULL) {
++                strncpy(smb2->error_string, errstr, MAX_ERROR_SIZE);
++        }
+ }
+ 
+ const char *smb2_get_error(struct smb2_context *smb2)
+ {
+-	return smb2 ? smb2->error_string : "";
++        return smb2 ? smb2->error_string : "";
+ }
+-        
++
+ const char *smb2_get_client_guid(struct smb2_context *smb2)
+ {
+         return smb2->client_guid;
+-- 
+2.20.1
+
diff --git a/contrib/src/smb2/0003-Fix-getlogin-usage.patch b/contrib/src/smb2/0003-Fix-getlogin-usage.patch
new file mode 100644
index 0000000000..91776d9f5f
--- /dev/null
+++ b/contrib/src/smb2/0003-Fix-getlogin-usage.patch
@@ -0,0 +1,70 @@
+From 434a880dc7f304eafb2377e26d47d93187109b14 Mon Sep 17 00:00:00 2001
+From: Thomas Guillem <thomas@gllm.fr>
+Date: Tue, 30 Jul 2019 18:02:14 +0200
+Subject: [PATCH 3/4] Fix getlogin() usage
+
+Use the reentrant version (the getlogin() string was statically allocated and
+could be overwritten on subsequent calls).
+
+Also check for error and use "Guest" as a fallback.
+---
+ lib/init.c | 20 ++++++++++++++++----
+ 1 file changed, 16 insertions(+), 4 deletions(-)
+
+diff --git a/lib/init.c b/lib/init.c
+index eab69a5..4387cd0 100644
+--- a/lib/init.c
++++ b/lib/init.c
+@@ -52,17 +52,27 @@
+ #define MAX_URL_SIZE 256
+ 
+ #ifdef _MSC_VER
+-#define getlogin() "Guest"
++#include <errno.h>
++#define getlogin_r(a,b) ENXIO
+ #define random rand
+ #define getpid GetCurrentProcessId
+ #endif // _MSC_VER
+ 
+ #ifdef ESP_PLATFORM
++#include <errno.h>
+ #include <esp_system.h>
+ #define random esp_random
+-#define getlogin() "Guest"
++#define getlogin_r(a,b) ENXIO
+ #endif
+ 
++#ifdef __ANDROID__
++#include <errno.h>
++// getlogin_r() was added in API 28
++#if __ANDROID_API__ < 28
++#define getlogin_r(a,b) ENXIO
++#endif
++#endif // __ANDROID__
++
+ static int
+ smb2_parse_args(struct smb2_context *smb2, const char *args)
+ {
+@@ -206,7 +216,8 @@ void smb2_destroy_url(struct smb2_url *url)
+ struct smb2_context *smb2_init_context(void)
+ {
+         struct smb2_context *smb2;
+-        int i;
++        char buf[1024];
++        int i, ret;
+ 
+         smb2 = malloc(sizeof(struct smb2_context));
+         if (smb2 == NULL) {
+@@ -214,7 +225,8 @@ struct smb2_context *smb2_init_context(void)
+         }
+         memset(smb2, 0, sizeof(struct smb2_context));
+ 
+-        smb2_set_user(smb2, getlogin());
++        ret = getlogin_r(buf, sizeof(buf));
++        smb2_set_user(smb2, ret == 0 ? buf : "Guest");
+         smb2->fd = -1;
+         smb2->sec = SMB2_SEC_UNDEFINED;
+         smb2->version = SMB2_VERSION_ANY;
+-- 
+2.20.1
+
diff --git a/contrib/src/smb2/0004-smb2_destroy_context-fix-possible-null-deref.patch b/contrib/src/smb2/0004-smb2_destroy_context-fix-possible-null-deref.patch
new file mode 100644
index 0000000000..ec8f9331b3
--- /dev/null
+++ b/contrib/src/smb2/0004-smb2_destroy_context-fix-possible-null-deref.patch
@@ -0,0 +1,48 @@
+From 6e2126a854292621548948a3d30e6023943d7c99 Mon Sep 17 00:00:00 2001
+From: Thomas Guillem <thomas@gllm.fr>
+Date: Thu, 8 Aug 2019 15:18:31 +0200
+Subject: [PATCH 4/4] smb2_destroy_context: fix possible null-deref
+
+This could happen when the smb2_close_async() command was aborted
+(smb2_service() not being called).
+---
+ lib/init.c | 16 ++++++++--------
+ 1 file changed, 8 insertions(+), 8 deletions(-)
+
+diff --git a/lib/init.c b/lib/init.c
+index 4387cd0..03903fb 100644
+--- a/lib/init.c
++++ b/lib/init.c
+@@ -255,14 +255,6 @@ void smb2_destroy_context(struct smb2_context *smb2)
+                 smb2->fd = -1;
+         }
+ 
+-        if (smb2->fhs) {
+-                smb2_free_all_fhs(smb2);
+-        }
+-
+-        if (smb2->dirs) {
+-                smb2_free_all_dirs(smb2);
+-        }
+-
+         while (smb2->outqueue) {
+                 struct smb2_pdu *pdu = smb2->outqueue;
+ 
+@@ -283,6 +275,14 @@ void smb2_destroy_context(struct smb2_context *smb2)
+                 smb2->pdu = NULL;
+         }
+ 
++        if (smb2->fhs) {
++                smb2_free_all_fhs(smb2);
++        }
++
++        if (smb2->dirs) {
++                smb2_free_all_dirs(smb2);
++        }
++
+         free(smb2->session_key);
+         smb2->session_key = NULL;
+ 
+-- 
+2.20.1
+
diff --git a/contrib/src/smb2/SHA512SUMS b/contrib/src/smb2/SHA512SUMS
new file mode 100644
index 0000000000..668b39e377
--- /dev/null
+++ b/contrib/src/smb2/SHA512SUMS
@@ -0,0 +1 @@
+08f421182a08f54d7a50afbfd83609093c1a62b24f7abe2a56ec833a36570916b20c8f046fcdb5ba8c8ed0311a19e8338b75839cd7cf752fc5b33a1367cf839f  libsmb2-3.0.0.tar.gz
diff --git a/contrib/src/smb2/rules.mak b/contrib/src/smb2/rules.mak
new file mode 100644
index 0000000000..1cee854204
--- /dev/null
+++ b/contrib/src/smb2/rules.mak
@@ -0,0 +1,31 @@
+# SMB2
+SMB2_VERSION := 3.0.0
+SMB2_URL := https://github.com/sahlberg/libsmb2/archive/v$(SMB2_VERSION).tar.gz
+
+ifdef BUILD_NETWORK
+ifndef HAVE_WIN32
+PKGS += smb2
+endif
+endif
+ifeq ($(call need_pkg,"smb2"),)
+PKGS_FOUND += smb2
+endif
+
+$(TARBALLS)/libsmb2-$(SMB2_VERSION).tar.gz:
+	$(call download_pkg,$(SMB2_URL),smb2)
+
+.sum-smb2: libsmb2-$(SMB2_VERSION).tar.gz
+
+smb2: libsmb2-$(SMB2_VERSION).tar.gz .sum-smb2
+	$(UNPACK)
+	$(APPLY) $(SRC)/smb2/0001-ntlmssp-add-support-for-Anonymous-logins.patch
+	$(APPLY) $(SRC)/smb2/0002-Fix-indent-and-white-spaces.patch
+	$(APPLY) $(SRC)/smb2/0003-Fix-getlogin-usage.patch
+	$(APPLY) $(SRC)/smb2/0004-smb2_destroy_context-fix-possible-null-deref.patch
+	$(MOVE)
+
+.smb2: smb2
+	cd $< && ./bootstrap
+	cd $< && $(HOSTVARS) ./configure --disable-examples --disable-werror --without-libkrb5 $(HOSTCONF)
+	cd $< && $(MAKE) install
+	touch $@
diff --git a/modules/MODULES_LIST b/modules/MODULES_LIST
index 051344019c..cbc2a52b69 100644
--- a/modules/MODULES_LIST
+++ b/modules/MODULES_LIST
@@ -363,6 +363,7 @@ $Id$
  * skins2: Skinnable interface, new generation
  * skiptags: APE & ID3 tags-skipping stream filter
  * smb: SMB shares access module
+ * smb2: SMB2/3 access module
  * smf: Standard MIDI file demuxer
  * sndio: OpenBSD sndio audio output
  * soxr: SoX Resampler library audio filter
diff --git a/modules/access/Makefile.am b/modules/access/Makefile.am
index 765ceec45f..2a773029e3 100644
--- a/modules/access/Makefile.am
+++ b/modules/access/Makefile.am
@@ -344,6 +344,17 @@ libdsm_plugin_la_LDFLAGS = $(AM_LDFLAGS) -rpath '$(accessdir)'
 access_LTLIBRARIES += $(LTLIBdsm)
 EXTRA_LTLIBRARIES += libdsm_plugin.la
 
+libsmb2_plugin_la_SOURCES = access/smb2.c
+libsmb2_plugin_la_CFLAGS = $(AM_CFLAGS) $(SMB2_CFLAGS)
+libsmb2_plugin_la_LIBADD = $(SMB2_LIBS) $(SOCKET_LIBS)
+libsmb2_plugin_la_LDFLAGS = $(AM_LDFLAGS) -rpath '$(accessdir)'
+if HAVE_DSM
+libsmb2_plugin_la_CFLAGS += $(DSM_CFLAGS) -DHAVE_DSM
+libsmb2_plugin_la_LIBADD += $(DSM_LIBS)
+endif
+access_LTLIBRARIES += $(LTLIBsmb2)
+EXTRA_LTLIBRARIES += libsmb2_plugin.la
+
 libtcp_plugin_la_SOURCES = access/tcp.c
 libtcp_plugin_la_LIBADD = $(SOCKET_LIBS)
 access_LTLIBRARIES += libtcp_plugin.la
diff --git a/modules/access/smb2.c b/modules/access/smb2.c
new file mode 100644
index 0000000000..6b56bf8706
--- /dev/null
+++ b/modules/access/smb2.c
@@ -0,0 +1,734 @@
+/*****************************************************************************
+ * smb2.c: SMB2 access plug-in
+ *****************************************************************************
+ * Copyright © 2018  VLC authors, VideoLAN and VideoLabs
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include <assert.h>
+#include <errno.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#ifdef HAVE_POLL
+# include <poll.h>
+#endif
+
+#include <vlc_common.h>
+#include <vlc_access.h>
+#include <vlc_dialog.h>
+#include <vlc_input_item.h>
+#include <vlc_plugin.h>
+#include <vlc_url.h>
+#include <vlc_keystore.h>
+#include <vlc_interrupt.h>
+#include <vlc_network.h>
+
+#include <smb2/smb2.h>
+#include <smb2/libsmb2.h>
+#include <smb2/libsmb2-raw.h>
+
+#ifdef HAVE_DSM
+# include <bdsm/netbios_ns.h>
+# include <bdsm/netbios_defs.h>
+
+# ifdef HAVE_ARPA_INET_H
+#  include <arpa/inet.h>
+# endif
+#endif
+
+#include "smb_common.h"
+
+static int Open(vlc_object_t *);
+static void Close(vlc_object_t *);
+
+vlc_module_begin()
+    set_shortname("smb2")
+    set_description(N_("SMB2 / SMB3 input"))
+    set_help(N_("Samba (Windows network shares) input via libsmb2"))
+    set_capability("access", 21)
+    set_category(CAT_INPUT)
+    set_subcategory(SUBCAT_INPUT_ACCESS)
+    add_string("smb-user", NULL, SMB_USER_TEXT, SMB_USER_LONGTEXT, false)
+    add_password("smb-pwd", NULL, SMB_PASS_TEXT, SMB_PASS_LONGTEXT, false)
+    add_string("smb-domain", NULL, SMB_DOMAIN_TEXT, SMB_DOMAIN_LONGTEXT, false)
+    add_shortcut("smb", "smb2")
+    set_callbacks(Open, Close)
+vlc_module_end()
+
+struct access_sys
+{
+    struct smb2_context *   smb2;
+    struct smb2fh *         smb2fh;
+    struct smb2dir *        smb2dir;
+    struct srvsvc_netshareenumall_rep *share_enum;
+    uint64_t                smb2_size;
+    vlc_url_t               encoded_url;
+    bool                    eof;
+    bool                    smb2_connected;
+    int                     error_status;
+
+    bool res_done;
+    union {
+        struct
+        {
+            size_t len;
+        } read;
+    } res;
+};
+
+static int
+smb2_check_status(stream_t *access, int status, const char *psz_func)
+{
+    struct access_sys *sys = access->p_sys;
+
+    if (status < 0)
+    {
+        const char *psz_error = smb2_get_error(sys->smb2);
+        msg_Warn(access, "%s failed: %d, '%s'", psz_func, status, psz_error);
+        sys->error_status = status;
+        return -1;
+    }
+    else
+    {
+        sys->res_done = true;
+        return 0;
+    }
+}
+
+static void
+smb2_set_generic_error(stream_t *access, const char *psz_func)
+{
+    struct access_sys *sys = access->p_sys;
+
+    msg_Err(access, "%s failed: %s", psz_func, smb2_get_error(sys->smb2));
+    sys->error_status = 1;
+}
+
+#define VLC_SMB2_CHECK_STATUS(access, status) \
+    smb2_check_status(access, status, __func__)
+
+#define VLC_SMB2_SET_GENERIC_ERROR(access, func) \
+    smb2_set_generic_error(access, func)
+
+#define VLC_SMB2_STATUS_DENIED(x) (x == -ECONNREFUSED || x == -EACCES)
+
+static int
+vlc_smb2_mainloop(stream_t *access, bool teardown)
+{
+#define TEARDOWN_TIMEOUT 250 /* in ms */
+    struct access_sys *sys = access->p_sys;
+
+    int timeout = -1;
+    int (*poll_func)(struct pollfd *, unsigned, int) = vlc_poll_i11e;
+
+    if (teardown)
+    {
+        /* Don't use vlc_poll_i11e that will return immediately with the EINTR
+         * errno if VLC's input is interrupted. Use the posix poll with a
+         * timeout to let a chance for a clean teardown. */
+        timeout = TEARDOWN_TIMEOUT;
+        poll_func = (void *)poll;
+        sys->error_status = 0;
+    }
+
+    sys->res_done = false;
+    while (sys->error_status == 0 && !sys->res_done)
+    {
+        struct pollfd p_fds[1];
+        int ret;
+        p_fds[0].fd = smb2_get_fd(sys->smb2);
+        p_fds[0].events = smb2_which_events(sys->smb2);
+
+        if (p_fds[0].fd == -1 || (ret = poll_func(p_fds, 1, timeout)) < 0)
+        {
+            if (errno == EINTR)
+            {
+                msg_Warn(access, "vlc_poll_i11e interrupted");
+                if (poll_func != (void *) poll)
+                {
+                    /* Try again with a timeout to let the command complete.
+                     * Indeed, if this command is interrupted, every future
+                     * commands will fail and we won't be able to teardown. */
+                    timeout = TEARDOWN_TIMEOUT;
+                    poll_func = (void *) poll;
+                }
+                else
+                    sys->error_status = -errno;
+            }
+            else
+            {
+                msg_Err(access, "vlc_poll_i11e failed");
+                sys->error_status = -errno;
+            }
+        }
+        else if (ret == 0)
+            sys->error_status = -ETIMEDOUT;
+        else if (ret > 0 && p_fds[0].revents
+             && smb2_service(sys->smb2, p_fds[0].revents) < 0)
+            VLC_SMB2_SET_GENERIC_ERROR(access, "smb2_service");
+    }
+    return sys->error_status == 0 ? 0 : -1;
+}
+
+#define VLC_SMB2_GENERIC_CB() \
+    VLC_UNUSED(smb2); \
+    stream_t *access = private_data; \
+    struct access_sys *sys = access->p_sys; \
+    assert(sys->smb2 == smb2); \
+    if (VLC_SMB2_CHECK_STATUS(access, status)) \
+        return
+
+static void
+smb2_generic_cb(struct smb2_context *smb2, int status, void *data,
+                void *private_data)
+{
+    VLC_UNUSED(data);
+    VLC_SMB2_GENERIC_CB();
+}
+
+static void
+smb2_read_cb(struct smb2_context *smb2, int status, void *data,
+             void *private_data)
+{
+    VLC_UNUSED(data);
+    VLC_SMB2_GENERIC_CB();
+
+    if (status == 0)
+        sys->eof = true;
+    else
+        sys->res.read.len = status;
+}
+
+static ssize_t
+FileRead(stream_t *access, void *buf, size_t len)
+{
+    struct access_sys *sys = access->p_sys;
+
+    if (sys->error_status != 0)
+        return -1;
+
+    if (sys->eof)
+        return 0;
+
+    sys->res.read.len = 0;
+    if (smb2_read_async(sys->smb2, sys->smb2fh, buf, len,
+                        smb2_read_cb, access) < 0)
+    {
+        VLC_SMB2_SET_GENERIC_ERROR(access, "smb2_read_async");
+        return -1;
+    }
+
+    if (vlc_smb2_mainloop(access, false) < 0)
+        return -1;
+
+    return sys->res.read.len;
+}
+
+static int
+FileSeek(stream_t *access, uint64_t i_pos)
+{
+    struct access_sys *sys = access->p_sys;
+
+    if (sys->error_status != 0)
+        return VLC_EGENERIC;
+
+    if (smb2_lseek(sys->smb2, sys->smb2fh, i_pos, SEEK_SET, NULL) < 0)
+    {
+        VLC_SMB2_SET_GENERIC_ERROR(access, "smb2_seek_async");
+        return VLC_EGENERIC;
+    }
+    sys->eof = false;
+
+    return VLC_SUCCESS;
+}
+
+static int
+FileControl(stream_t *access, int i_query, va_list args)
+{
+    struct access_sys *sys = access->p_sys;
+
+    switch (i_query)
+    {
+        case STREAM_CAN_SEEK:
+            *va_arg(args, bool *) = true;
+            break;
+
+        case STREAM_CAN_FASTSEEK:
+            *va_arg(args, bool *) = false;
+            break;
+
+        case STREAM_CAN_PAUSE:
+        case STREAM_CAN_CONTROL_PACE:
+            *va_arg(args, bool *) = true;
+            break;
+
+        case STREAM_GET_SIZE:
+        {
+            *va_arg(args, uint64_t *) = sys->smb2_size;
+            break;
+        }
+
+        case STREAM_GET_PTS_DELAY:
+            *va_arg( args, int64_t * ) = INT64_C(1000)
+                * var_InheritInteger( access, "network-caching" );
+            break;
+
+        case STREAM_SET_PAUSE_STATE:
+            break;
+
+        default:
+            return VLC_EGENERIC;
+    }
+    return VLC_SUCCESS;
+}
+
+static char *
+vlc_smb2_get_url(vlc_url_t *url, const char *file)
+{
+    /* smb2://<psz_host><psz_path><file>?<psz_option> */
+    char *buf;
+    if (asprintf(&buf, "smb://%s%s%s%s%s%s", url->psz_host,
+                 url->psz_path != NULL ? url->psz_path : "",
+                 url->psz_path != NULL && url->psz_path[0] != '\0' &&
+                 url->psz_path[strlen(url->psz_path) - 1] != '/' ? "/" : "",
+                 file,
+                 url->psz_option != NULL ? "?" : "",
+                 url->psz_option != NULL ? url->psz_option : "") == -1)
+        return NULL;
+    else
+        return buf;
+}
+
+static int AddItem(stream_t *access, struct vlc_readdir_helper *rdh,
+                   const char *name, int i_type)
+{
+    struct access_sys *sys = access->p_sys;
+    char *name_encoded = vlc_uri_encode(name);
+    if (name_encoded == NULL)
+        return VLC_ENOMEM;
+
+    char *url = vlc_smb2_get_url(&sys->encoded_url, name_encoded);
+    free(name_encoded);
+    if (url == NULL)
+        return VLC_ENOMEM;
+
+    int ret = vlc_readdir_helper_additem(rdh, url, NULL, name, i_type,
+                                         ITEM_NET);
+    free(url);
+    return ret;
+}
+
+static int
+DirRead(stream_t *access, input_item_node_t *p_node)
+{
+    struct access_sys *sys = access->p_sys;
+    struct smb2dirent *smb2dirent;
+    int ret = VLC_SUCCESS;
+    assert(sys->smb2dir);
+
+    struct vlc_readdir_helper rdh;
+    vlc_readdir_helper_init(&rdh, access, p_node);
+
+    while (ret == VLC_SUCCESS
+        && (smb2dirent = smb2_readdir(sys->smb2, sys->smb2dir)) != NULL)
+    {
+        int i_type;
+        switch (smb2dirent->st.smb2_type)
+        {
+        case SMB2_TYPE_FILE:
+            i_type = ITEM_TYPE_FILE;
+            break;
+        case SMB2_TYPE_DIRECTORY:
+            i_type = ITEM_TYPE_DIRECTORY;
+            break;
+        default:
+            i_type = ITEM_TYPE_UNKNOWN;
+            break;
+        }
+        ret = AddItem(access, &rdh, smb2dirent->name, i_type);
+    }
+
+    vlc_readdir_helper_finish(&rdh, ret == VLC_SUCCESS);
+
+    return ret;
+}
+
+static int
+ShareEnum(stream_t *access, input_item_node_t *p_node)
+{
+    struct access_sys *sys = access->p_sys;
+    assert(sys->share_enum != NULL);
+
+    int ret = VLC_SUCCESS;
+    struct vlc_readdir_helper rdh;
+    vlc_readdir_helper_init(&rdh, access, p_node);
+
+    struct srvsvc_netsharectr *ctr = sys->share_enum->ctr;
+    for (uint32_t iinfo = 0;
+         iinfo < ctr->ctr1.count && ret == VLC_SUCCESS; ++iinfo)
+    {
+       struct srvsvc_netshareinfo1 *info = &ctr->ctr1.array[iinfo];
+       if (info->type & SHARE_TYPE_HIDDEN)
+           continue;
+       switch (info->type & 0x3)
+       {
+           case SHARE_TYPE_DISKTREE:
+               ret = AddItem(access, &rdh, info->name, ITEM_TYPE_DIRECTORY);
+               break;
+       }
+    }
+
+    vlc_readdir_helper_finish(&rdh, ret == VLC_SUCCESS);
+    return 0;
+}
+
+static int
+vlc_smb2_close_fh(stream_t *access)
+{
+    struct access_sys *sys = access->p_sys;
+
+    assert(sys->smb2fh);
+
+    if (smb2_close_async(sys->smb2, sys->smb2fh, smb2_generic_cb, access) < 0)
+    {
+        VLC_SMB2_SET_GENERIC_ERROR(access, "smb2_close_async");
+        return -1;
+    }
+
+    sys->smb2fh = NULL;
+
+    return vlc_smb2_mainloop(access, true);
+}
+
+static int
+vlc_smb2_disconnect_share(stream_t *access)
+{
+    struct access_sys *sys = access->p_sys;
+
+    if (!sys->smb2_connected)
+        return 0;
+
+    if (smb2_disconnect_share_async(sys->smb2, smb2_generic_cb, access) < 0)
+    {
+        VLC_SMB2_SET_GENERIC_ERROR(access, "smb2_connect_share_async");
+        return -1;
+    }
+
+    int ret = vlc_smb2_mainloop(access, true);
+    sys->smb2_connected = false;
+    return ret;
+}
+
+static void
+smb2_opendir_cb(struct smb2_context *smb2, int status, void *data,
+                void *private_data)
+{
+    VLC_SMB2_GENERIC_CB();
+
+    sys->smb2dir = data;
+}
+
+static void
+smb2_open_cb(struct smb2_context *smb2, int status, void *data,
+             void *private_data)
+{
+    VLC_SMB2_GENERIC_CB();
+
+    sys->smb2fh = data;
+}
+
+static void
+smb2_share_enum_cb(struct smb2_context *smb2, int status, void *data,
+                   void *private_data)
+{
+    VLC_SMB2_GENERIC_CB();
+
+    sys->share_enum = data;
+}
+
+static int
+vlc_smb2_open_share(stream_t *access, const struct smb2_url *smb2_url,
+                    const vlc_credential *credential)
+{
+    struct access_sys *sys = access->p_sys;
+
+    const bool do_enum = smb2_url->share[0] == '\0';
+    const char *username = credential->psz_username;
+    const char *password = credential->psz_password;
+    const char *domain = credential->psz_realm;
+    const char *share = do_enum ? "IPC$" : smb2_url->share;
+
+    if (!username)
+    {
+        username = "Guest";
+        /* A NULL password enable ntlmssp anonymous login */
+        password = NULL;
+    }
+
+    smb2_set_password(sys->smb2, password);
+    smb2_set_domain(sys->smb2, domain ? domain : "");
+
+    if (smb2_connect_share_async(sys->smb2, smb2_url->server, share,
+                                 username, smb2_generic_cb, access) < 0)
+    {
+        VLC_SMB2_SET_GENERIC_ERROR(access, "smb2_connect_share_async");
+        goto error;
+    }
+    if (vlc_smb2_mainloop(access, false) != 0)
+        goto error;
+    sys->smb2_connected = true;
+
+    int ret;
+    if (do_enum)
+        ret = smb2_share_enum_async(sys->smb2, smb2_share_enum_cb, access);
+    else
+    {
+        struct smb2_stat_64 smb2_stat;
+        if (smb2_stat_async(sys->smb2, smb2_url->path, &smb2_stat,
+                            smb2_generic_cb, access) < 0)
+            VLC_SMB2_SET_GENERIC_ERROR(access, "smb2_stat_async");
+
+        if (vlc_smb2_mainloop(access, false) != 0)
+            goto error;
+
+        if (smb2_stat.smb2_type == SMB2_TYPE_FILE)
+        {
+            sys->smb2_size = smb2_stat.smb2_size;
+            ret = smb2_open_async(sys->smb2, smb2_url->path, O_RDONLY,
+                                  smb2_open_cb, access);
+        }
+        else if (smb2_stat.smb2_type == SMB2_TYPE_DIRECTORY)
+            ret = smb2_opendir_async(sys->smb2, smb2_url->path,
+                                     smb2_opendir_cb, access);
+        else
+        {
+            msg_Err(access, "smb2_stat_cb: file type not handled");
+            sys->error_status = 1;
+            goto error;
+        }
+    }
+
+    if (ret < 0)
+    {
+        VLC_SMB2_SET_GENERIC_ERROR(access, "smb2_open*_async");
+        goto error;
+    }
+
+    if (vlc_smb2_mainloop(access, false) != 0)
+        goto error;
+    return 0;
+
+error:
+    vlc_smb2_disconnect_share(access);
+    return -1;
+}
+
+static char *
+vlc_smb2_resolve(stream_t *access, const char *host, unsigned port)
+{
+    (void) access;
+    if (!host)
+        return NULL;
+
+#ifdef HAVE_DSM
+    /* Test if the host is an IP */
+    struct in_addr addr;
+    if (inet_pton(AF_INET, host, &addr) == 1)
+        return NULL;
+
+    /* Test if the host can be resolved */
+    struct addrinfo *info = NULL;
+    if (vlc_getaddrinfo_i11e(host, port, NULL, &info) == 0)
+    {
+        freeaddrinfo(info);
+        /* Let smb2 resolve it */
+        return NULL;
+    }
+
+    /* Test if the host is a netbios name */
+    char *out_host = NULL;
+    netbios_ns *ns = netbios_ns_new();
+    uint32_t ip4_addr;
+    if (netbios_ns_resolve(ns, host, NETBIOS_FILESERVER, &ip4_addr) == 0)
+    {
+        char ip[] = "xxx.xxx.xxx.xxx";
+        if (inet_ntop(AF_INET, &ip4_addr, ip, sizeof(ip)))
+            out_host = strdup(ip);
+    }
+    netbios_ns_destroy(ns);
+    return out_host;
+#else
+    (void) port;
+    return NULL;
+#endif
+}
+
+static int
+Open(vlc_object_t *p_obj)
+{
+    stream_t *access = (stream_t *)p_obj;
+    struct access_sys *sys = vlc_obj_calloc(p_obj, 1, sizeof (*sys));
+    struct smb2_url *smb2_url = NULL;
+    char *var_domain = NULL;
+
+    if (unlikely(sys == NULL))
+        return VLC_ENOMEM;
+    access->p_sys = sys;
+
+    /* Parse the encoded URL */
+    if (vlc_UrlParseFixup(&sys->encoded_url, access->psz_url) != 0)
+        return VLC_ENOMEM;
+
+    sys->smb2 = smb2_init_context();
+    if (sys->smb2 == NULL)
+    {
+        msg_Err(access, "smb2_init_context failed");
+        goto error;
+    }
+
+    smb2_set_security_mode(sys->smb2, SMB2_NEGOTIATE_SIGNING_ENABLED);
+
+    if (sys->encoded_url.psz_path == NULL)
+        sys->encoded_url.psz_path = (char *) "/";
+
+    char *resolved_host = vlc_smb2_resolve(access, sys->encoded_url.psz_host,
+                                           sys->encoded_url.i_port);
+
+    /* smb2_* functions need a decoded url. Re compose the url from the
+     * modified sys->encoded_url (with the resolved host). */
+    char *url;
+    if (resolved_host != NULL)
+    {
+        vlc_url_t resolved_url = sys->encoded_url;
+        resolved_url.psz_host = resolved_host;
+        url = vlc_uri_compose(&resolved_url);
+        free(resolved_host);
+    }
+    else
+        url = vlc_uri_compose(&sys->encoded_url);
+    if (!vlc_uri_decode(url))
+    {
+        free(url);
+        goto error;
+    }
+    smb2_url = smb2_parse_url(sys->smb2, url);
+    free(url);
+
+    if (!smb2_url || !smb2_url->share || !smb2_url->server)
+    {
+        msg_Err(access, "smb2_parse_url failed");
+        goto error;
+    }
+
+    int ret = -1;
+    vlc_credential credential;
+    vlc_credential_init(&credential, &sys->encoded_url);
+    var_domain = var_InheritString(access, "smb-domain");
+    credential.psz_realm = var_domain;
+
+    /* First, try Guest login or using "smb-" options (without
+     * keystore/user interaction) */
+    vlc_credential_get(&credential, access, "smb-user", "smb-pwd", NULL,
+                       NULL);
+    ret = vlc_smb2_open_share(access, smb2_url, &credential);
+
+    while (ret == -1
+        && (!sys->error_status || VLC_SMB2_STATUS_DENIED(sys->error_status))
+        && vlc_credential_get(&credential, access, "smb-user", "smb-pwd",
+                              SMB_LOGIN_DIALOG_TITLE, SMB_LOGIN_DIALOG_TEXT,
+                              smb2_url->server))
+    {
+        sys->error_status = 0;
+        ret = vlc_smb2_open_share(access, smb2_url, &credential);
+    }
+    if (ret == 0)
+        vlc_credential_store(&credential, access);
+    vlc_credential_clean(&credential);
+
+    if (ret != 0)
+    {
+        const char *error = smb2_get_error(sys->smb2);
+        if (error && *error)
+            vlc_dialog_display_error(access,
+                                     _("SMB2 operation failed"), "%s", error);
+        goto error;
+    }
+
+    if (sys->smb2fh != NULL)
+    {
+        access->pf_read = FileRead;
+        access->pf_seek = FileSeek;
+        access->pf_control = FileControl;
+    }
+    else if (sys->smb2dir != NULL)
+    {
+        access->pf_readdir = DirRead;
+        access->pf_seek = NULL;
+        access->pf_control = access_vaDirectoryControlHelper;
+    }
+    else if (sys->share_enum != NULL)
+    {
+        access->pf_readdir = ShareEnum;
+        access->pf_seek = NULL;
+        access->pf_control = access_vaDirectoryControlHelper;
+    }
+    else
+        vlc_assert_unreachable();
+
+    smb2_destroy_url(smb2_url);
+    free(var_domain);
+    return VLC_SUCCESS;
+
+error:
+    if (smb2_url != NULL)
+        smb2_destroy_url(smb2_url);
+    if (sys->smb2 != NULL)
+    {
+        vlc_smb2_disconnect_share(access);
+        smb2_destroy_context(sys->smb2);
+    }
+    vlc_UrlClean(&sys->encoded_url);
+    free(var_domain);
+    return VLC_EGENERIC;
+}
+
+static void
+Close(vlc_object_t *p_obj)
+{
+    stream_t *access = (stream_t *)p_obj;
+    struct access_sys *sys = access->p_sys;
+
+    if (sys->smb2fh != NULL)
+        vlc_smb2_close_fh(access);
+    else if (sys->smb2dir != NULL)
+        smb2_closedir(sys->smb2, sys->smb2dir);
+    else if (sys->share_enum != NULL)
+        smb2_free_data(sys->smb2, sys->share_enum);
+    else
+        vlc_assert_unreachable();
+
+    vlc_smb2_disconnect_share(access);
+    smb2_destroy_context(sys->smb2);
+
+    vlc_UrlClean(&sys->encoded_url);
+}
diff --git a/po/POTFILES.in b/po/POTFILES.in
index 2b4319f140..80d972223d 100644
--- a/po/POTFILES.in
+++ b/po/POTFILES.in
@@ -214,6 +214,7 @@ modules/access/sftp.c
 modules/access/shm.c
 modules/access/smb.c
 modules/access/smb_common.h
+modules/access/smb2.c
 modules/access/srt.c
 modules/access/tcp.c
 modules/access/timecode.c
-- 
2.20.1

